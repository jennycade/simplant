{"version":3,"sources":["helpers.js","GrowingTip.js","Flower.js","Plant.js","Resource.js","Habitat.js","Game.js","App.js","index.js"],"names":["parseCoord","coord","undefined","Error","split","map","x","parseInt","unparseCoord","y","GrowingTip","dir","origin","isShoot","includes","isRoot","getNextCoord","getOrigin","grow","Flower","stages","nextVerb","minTime","nextStage","time","stage","Object","keys","seeds","getNextVerb","isVerbReady","getCoord","getStage","getSeeds","incTime","doVerb","verb","Plant","midpoint","midline","coords","growingTips","usedOrigins","flowers","usedFlowerCoords","doFlowerVerb","i","length","plantPart","checkFn","newCoords","newCoord","assign","newTip","ydir","potentialOrigins","flatMap","result","str","availableOrigins","filter","Math","floor","random","substring","push","newShoot","newRoot","bloom","availableFlowerCoords","entries","val","flowerCoord","flower","getCoords","setCoords","sprout","shootMeristem","shoot","rootMeristem","root","containsShoot","containsRoot","getFlowerVerbs","nextVerbs","readyVerbs","growShoots","growRoots","tick","countCells","type","numShootCells","numRootCells","numFlowerCells","flowerStages","toString","codes","coordsArr","lastCoord","xmax","ymax","status","Resource","legalCoords","minCoord","maxCoord","xmin","ymin","isLegalxCoord","legal","move","xdiff","ydiff","xchoices","areCoordsLegal","getType","Habitat","soilLine","plant","resources","sunCoords","waterCoords","getAbiotic","mapCoords","plantCoords","resourcesCoords","resCoords","j","createGrid","width","height","xmid","ymidShoot","ymidRoot","setMidpoint","setResourceCoords","setMidline","createPlant","createSun","sun","createWater","water","getMaxCoord","getMidpoint","getMidline","getResources","harvestResource","resourcesToRemove","resource","pixel","code","environment","join","getMap","getPlant","Game","hab","energy","verbMenu","cost","area","init","createResource","getReadyVerbs","verbs","flowerVerbs","flat","getEnergy","getTime","App","useState","display","setDisplay","game","setGame","setMap","setEnergy","setTime","timer","setTimer","setSeeds","setReadyVerbs","newGame","clearInterval","XMAX","YMAX","setInterval","gameToTick","endGame","instructions","className","onClick","habitat","pixelDisplay","text","harvestable","console","log","renderMap","error","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d2f40044.chunk.js","sourcesContent":["\nconst parseCoord = (coord) => { // TODO: Write some error-catching here. If plant.sprout() is called before plant.setCoords(), this function is called with coord = undefined.\n  if (coord === undefined) {\n    throw(new Error(`Called parseCoord(undefined)`));\n  }\n  const coords = coord.split(',');\n  return coords.map(x => parseInt(x));\n}\nconst unparseCoord = (x, y) => {\n  return `${x},${y}`;\n}\n\nexport {\n  parseCoord, unparseCoord,\n};","import { parseCoord, unparseCoord } from \"./helpers\";\n\nconst GrowingTip = (coord, dir) => {\n\n  const origin = coord;\n\n  const getOrigin = () => {\n    return origin;\n  }\n\n  const isShoot = () => {\n    return dir.includes('u');\n  }\n\n  const isRoot = () => {\n    return dir.includes('d');\n  }\n\n  const grow = () => {\n    return getNextCoord();\n  }\n\n  const getNextCoord = () => {\n    let [x, y] = parseCoord(coord);\n    // TODO: put this all in a try block and have Grid catch it\n    if (isShoot()) {\n      y -= 1;\n    }\n    if (isRoot()) {\n      y += 1\n    }\n    if (dir.includes('l')) {\n      x -= 1;\n    }\n    if (dir.includes('r')) {\n      x += 1;\n    }\n\n    coord = unparseCoord(x, y);\n    return coord;\n  }\n\n  return {\n    getOrigin,\n    isShoot, isRoot,\n    grow,\n  };\n}\n\nexport default GrowingTip;","const Flower = (coord) => {\n\n  const stages = {\n    'bud': {\n      nextVerb: 'blossom',\n      minTime: 5,\n      nextStage: 'flower',\n    },\n    'flower': {\n      nextVerb: 'fertilize',\n      minTime: 5,\n      nextStage: 'fertilized flower',\n    },\n    'fertilized flower': {\n      nextVerb: 'fruit',\n      minTime: 5,\n      nextStage: 'fruit',\n    },\n    'fruit': {\n      nextVerb: 'ripen',\n      minTime: 5,\n      nextStage: 'ripe fruit',\n    },\n    'ripe fruit': {\n      nextVerb: 'disperse',\n      minTime: 5,\n      nextStage: 'dispersed seeds',\n    },\n    'dispersed seeds': {\n      nextVerb: null,\n      minTime: 5,\n      nextStage: null,\n    },\n  };\n\n  let time = 0;\n\n  let stage = Object.keys(stages)[0];\n\n  let seeds = 0;\n\n  const getCoord = () => coord;\n\n  const getStage = () => { return stage; }\n\n  const getSeeds = () => { return seeds }\n\n  const getNextVerb = () => {\n    // for displaying the user action button\n    return stages[stage].nextVerb;\n  }\n\n  const isVerbReady = () => {\n    // true if time >= minTime\n    const minTime = stages[stage].minTime;\n\n    return ( time >= minTime );\n  }\n\n  const incTime = () => {\n    time ++;\n  }\n\n  const incStage = () => {\n    // set stage\n    stage = stages[stage].nextStage;\n\n    // reset time\n    time = 0;\n  }\n\n  const doVerb = (verb) => {\n    // only do it if stage and time are right\n    if (getNextVerb() === verb && isVerbReady()) {\n      // do it\n      incStage();\n    } // TODO: Throw an error as an else clause (and update tests)\n\n    if (stage === 'dispersed seeds') { // TODO: Don't hardcode in this value; check to see if it's the last stage instead\n      // disperse some seeds!\n      seeds = 100; // TODO: Randomly generate the number of seeds\n    }\n  }\n\n  return {\n    getCoord,\n    getStage, getSeeds,\n    getNextVerb, isVerbReady,\n    incTime,\n    doVerb,\n  };\n}\n\nexport default Flower;","import GrowingTip from \"./GrowingTip\";\nimport Flower from './Flower';\nimport { parseCoord, unparseCoord } from \"./helpers\";\n\nconst Plant = (midpoint, midline) => {\n\n  let coords = {};\n\n  // for new shoots and roots\n  let growingTips = [];\n  let usedOrigins = [];\n\n  // for flowers\n  let flowers = [];\n  let usedFlowerCoords = [];\n\n  const setCoords = (newCoords) => {\n    // takes an array of coord strings, uses that as keys\n    // sets coords to be an object with coord keys and 'shoot', 'root', or 'empty'\n    for (let i = 0; i < newCoords.length; i++) {\n      coords[newCoords[i]] = '';\n    }\n  }\n\n  // contains functions\n  const containsShoot = (coord) => {\n    return coords[coord] === 'shoot';\n  }\n  const containsRoot = (coord) => {\n    return coords[coord] === 'root';\n  }\n\n  \n  const sprout = () => {\n    // sprout!\n    // make two growing tips: one shoot and one root\n    // two pixels at the middle of the grid\n\n    // growing tips\n    const shootMeristem = GrowingTip(midpoint.shoot, 'u');\n    const rootMeristem = GrowingTip(midpoint.root, 'd');\n    growingTips = [shootMeristem, rootMeristem];\n\n    coords[midpoint.shoot] = 'shoot';\n    coords[midpoint.root] = 'root';\n\n    return true;\n  }\n\n  // user growth actions\n  const doVerb = (verb) => {\n    const verbs = {\n      'growShoots': () => grow('shoot'),\n      'growRoots': () => grow('root'),\n      'newShoot': newShoot,\n      'newRoot': newRoot,\n      'bloom': bloom,\n      'blossom': () => doFlowerVerb('blossom'),\n      'fertilize': () => doFlowerVerb('fertilize'),\n      'fruit': () => doFlowerVerb('fruit'),\n      'ripen': () => doFlowerVerb('ripen'),\n      'disperse': () => doFlowerVerb('disperse'),\n    }\n\n    const result = verbs[verb]();\n    return result;\n  }\n\n  const getFlowerVerbs = () => { // TODO: Make sure Habitat has this info on every tick\n    // returns [nextVerbs, readyVerbs]\n    let nextVerbs = [];\n    let readyVerbs = [];\n    // iterate through flowers\n    for (let i = 0; i < flowers.length; i++) {\n      const nextVerb = flowers[i].getNextVerb();\n      // unique and not null?\n      if (! nextVerbs.includes(nextVerb) && nextVerb) {\n        nextVerbs.push(nextVerb);\n      }\n      // available?\n      if (flowers[i].isVerbReady()) {\n        // unique and not null?\n        if (! readyVerbs.includes(nextVerb) && nextVerb) {\n          readyVerbs.push(nextVerb);\n        }\n      }\n    }\n    return [nextVerbs, readyVerbs];\n  }\n\n  const doFlowerVerb = (verb) => {\n    // iterate through flowers\n    for (let i = 0; i < flowers.length; i++) {\n      // see if it's available\n      if (flowers[i].getNextVerb() === verb && flowers[i].isVerbReady()) {\n        // do it\n        flowers[i].doVerb(verb);\n        // update coords\n        coords[flowers[i].getCoord()] = flowers[i].getStage();\n\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // verbs\n  const grow = (plantPart) => {\n    let checkFn;\n    if (plantPart === 'shoot') {\n      checkFn = 'isShoot';\n    }\n    if (plantPart === 'root') {\n      checkFn = 'isRoot';\n    }\n\n    let newCoords = {};\n\n    // iterate over the growing tips\n    for (let i = 0; i < growingTips.length; i++) {\n      if (growingTips[i][checkFn]()) {\n        // grow\n        const newCoord = growingTips[i].grow();\n\n        // check to make sure it's on the board\n        if (Object.keys(coords).includes(newCoord)) {\n          // get ready to add new coord to the plant\n          newCoords[newCoord] = plantPart;\n        }\n        \n      }\n    }\n\n    if (Object.keys(newCoords).length > 0) {\n      // add new coords to the plant\n      Object.assign(coords, newCoords);\n      return true;\n    } else { // growth would have gone off the board\n      return false;\n    }\n  }\n\n  const growShoots = () => {\n    return grow('shoot');\n  }\n  const growRoots = () => {\n    return grow('root');\n  }\n\n  const newTip = (plantPart) => {\n    let ydir = '';\n    // encode y direction\n    if (plantPart === 'shoot') {\n      ydir = 'u';\n    }\n    if (plantPart === 'root') {\n      ydir = 'd';\n    }\n    // pick an origin\n    const coordsArr = Object.keys(coords);\n    let potentialOrigins = coordsArr.flatMap(coord => {\n      let result = '';\n      // coord is on midline; xcoord === midline\n      const [x, y] = parseCoord(coord);\n      if (x === midline) {\n        if (coords[coord] === plantPart) {\n          let str = `${coord}${ydir}`; // add u for shoot and r for root\n          result = [str+'l', str+'r']; // add l and r for our beautiful 2D plant\n        }\n      }\n      return result;\n    });\n\n    potentialOrigins = potentialOrigins.filter(x => x !== '');\n\n    // subtract usedOrigins from potentialOrigins\n    const availableOrigins = potentialOrigins.filter(x => !usedOrigins.includes(x));\n\n    if (availableOrigins.length > 0) {\n\n      // choose an origin randomly\n      const origin = availableOrigins[Math.floor(Math.random() * availableOrigins.length)];\n\n      // make a new GrowingTip()\n\n      // parse the origin: 'x,yul'\n      // TODO: consider writing a parseOriginCode() function (But this might be the only place it gets used)\n      const coord = origin.substring(0, origin.length - 2);\n      const dir = origin.substring(origin.length - 2);\n\n      // add to growing tips\n      const newTip = GrowingTip(coord, dir);\n      growingTips.push(newTip);\n\n      // add origin to usedOrigins\n      usedOrigins.push(origin);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  const newShoot = () => {\n    return newTip('shoot');\n  }\n  const newRoot = () => {\n    return newTip('root');\n  }\n  const bloom = () => {\n    // pick a shoot cell to convert to a flower\n    const availableFlowerCoords = [];\n\n    for (const [coord, val] of Object.entries(coords)) {\n      if ( !usedFlowerCoords.includes(coord) && val === 'shoot' ) {\n        availableFlowerCoords.push(coord);\n      }\n    }\n\n    const flowerCoord = availableFlowerCoords[Math.floor(Math.random() * availableFlowerCoords.length)];\n    if (flowerCoord) {\n      // make new Flower()\n      const flower = Flower(flowerCoord);\n      flowers.push(flower);\n\n      // update coords\n      coords[flowerCoord] = flower.getStage(); // TODO: update by stage\n\n      // add to usedFlowerCoords\n      usedFlowerCoords.push(flowerCoord);\n\n      return flower;\n    } else {\n      // no space to flower\n      return false;\n    }\n  }\n\n  const getCoords = () => coords;\n\n  const tick = () => {\n    // time progresses for flowers\n    for (let i = 0; i < flowers.length; i++) {\n      flowers[i].incTime();\n    }\n  }\n\n  const getSeeds = () => {\n    // returns total number of seeds from all flowers\n    // TODO: rewrite as a var that gets updated when a flower disperses seeds\n    let seeds = 0;\n    for (let i = 0; i < flowers.length; i++) {\n      seeds += flowers[i].getSeeds();\n    }\n\n    return seeds;\n  }\n\n  // for dev: count cells\n  const countCells = (type) => {\n    let numShootCells = 0;\n    let numRootCells = 0;\n    let numFlowerCells = 0;\n\n    const flowerStages = ['bud', 'flower', 'fertilized flower', 'fruit', 'ripe fruit', 'dispersed seeds'];\n\n    // count the occupied coordinates\n    for (const [coord, val] of Object.entries(coords)) {\n      if (val === 'shoot') {\n        numShootCells++;\n      }\n      if (val === 'root') {\n        numRootCells++;\n      }\n      if (flowerStages.includes(val)) {\n        numFlowerCells++;\n      }\n    }\n\n    if (type === 'shoot') {\n      return numShootCells;\n    } else if (type === 'root') {\n      return numRootCells;\n    } else if (type === 'flower') {\n      return numFlowerCells;\n    } else {\n      return numShootCells + numRootCells + numFlowerCells;\n    }\n    \n  }\n\n  // also (probably) for dev: toString()\n  const toString = () => {\n    const codes = {\n      'shoot':  's',\n      'root':   'r',\n      'bud':               '1',\n      'flower':            '2',\n      'fertilized flower': '3',\n      'fruit':             '4',\n      'ripe fruit':        '5',\n      'dispersed seeds':   '6',\n    };\n\n    let str = '';\n    // coords = {'0,0': '', '1,0': '', ..., 'xmax,ymax': ''}\n    // parse last coord\n    const coordsArr = Object.keys(coords);\n    const lastCoord = coordsArr[coordsArr.length - 1];\n    const [xmax, ymax] = parseCoord(lastCoord);\n\n    // iterate row-by-row\n    for (let y = 0; y < ymax + 1; y++) {\n      for (let x = 0; x < xmax + 1; x++) {\n        const status = coords[unparseCoord(x, y)]\n        let code = '';\n\n        if (status === '') {\n          code = '-';\n        } else {\n          // first character\n          code = codes[status];\n        }\n\n        str += code;\n      }\n      str += '\\n';\n    }\n    return str;\n  }\n\n  return {\n    coords, getCoords,\n    setCoords,\n    sprout,\n    containsShoot,\n    containsRoot,\n    // TODO: write containsFlower\n    doVerb,\n    getFlowerVerbs,\n    growShoots, growRoots,\n    newShoot, newRoot,\n    bloom,\n    tick,\n    getSeeds,\n\n    countCells,\n    toString,\n  };\n}\n\nexport default Plant;","import { parseCoord, unparseCoord } from './helpers';\n\nconst Resource = (type, legalCoords) => {\n  let coords = [];\n\n  // set min and max x and y coordinates\n  const minCoord = legalCoords[0];\n  const maxCoord = legalCoords[legalCoords.length - 1];\n\n  const [xmin, ymin] = parseCoord(minCoord);\n  const [xmax, ymax] = parseCoord(maxCoord);\n  \n  // randomly pick a starting coord\n  const x = Math.floor(Math.random() * (xmax + 1));\n  const y = type === 'sun' ? 0 : ymax;\n\n  coords.push(unparseCoord(x, y));\n\n  const isLegalxCoord = (newCoords) => {\n    let legal = true;\n    for (let i = 0; i < newCoords.length; i++) {\n      const [x, y] = parseCoord(newCoords[i]);\n      if (x < xmin || x > xmax) {\n        legal = false;\n      }\n    }\n    return legal;\n  }\n\n  const areCoordsLegal = () => {\n    for (let i = 0; i < coords.length; i++) {\n      const [x, y] = parseCoord(coords[i]);\n      if (x < xmin || x > xmax || y < ymin || y > ymax) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  const move = () => {\n    // set change in position\n    let xdiff, ydiff, newCoords;\n    const xchoices = [-1, 0, 1]; \n    do {\n      if (type === 'sun') {\n        // straight down\n        xdiff = 0;\n        ydiff = 1;\n      }\n      if (type === 'water') {\n        // up and randomly to one side or straight up\n        xdiff = xchoices[Math.floor(Math.random() * xchoices.length)];\n        ydiff = -1;\n      }\n\n      newCoords = [];\n      // change coords\n      for (let i = 0; i < coords.length; i++ ) {\n        let [x, y] = parseCoord(coords[i]);\n        const newCoord = unparseCoord(x + xdiff, y + ydiff);\n        newCoords.push(newCoord);\n      }\n    } while (! isLegalxCoord(newCoords) )\n\n    coords = newCoords;\n    return newCoords;\n  }\n\n  const getCoords = () => coords;\n  const getType = () => type;\n\n  return {\n    move,\n    areCoordsLegal,\n    getCoords,\n    getType\n  }\n}\n\nexport default Resource;","import Plant from './Plant';\nimport Resource from './Resource';\nimport { parseCoord, unparseCoord } from './helpers';\n\nconst Habitat = () => {\n  let coords = [];\n  let maxCoord = '';\n  let plant = null;\n  let resources = [];\n\n  let midpoint = {\n    shoot: '',\n    root: '',\n  };\n  let midline;\n  let soilLine;\n  let sunCoords = [];\n  let waterCoords = [];\n\n  let map = {};\n\n  const setMidpoint = () => { \n    const [xmax, ymax] = parseCoord(maxCoord);\n  \n    // find mid x coord\n    const xmid = Math.floor(xmax / 2);\n  \n    // find mid y coord\n    const ymidShoot = Math.floor(ymax / 2);\n    const ymidRoot = ymidShoot + 1;\n  \n    // set value\n    midpoint.shoot = unparseCoord(xmid, ymidShoot);\n    midpoint.root = unparseCoord(xmid, ymidRoot);\n\n    // set soilLine too\n    soilLine = ymidRoot;\n  }\n\n  const setResourceCoords = () => {\n    // sunCoords = everything with y < soilLine\n    // waterCoords = everything with y >= soilLine\n    for (let i = 0; i < coords.length; i++) {\n      const y = parseCoord(coords[i])[1];\n      if (y < soilLine) {\n        sunCoords.push(coords[i]);\n      } else {\n        waterCoords.push(coords[i]);\n      }\n    }\n  }\n\n  const setMidline = () => {\n    const xmax = parseCoord(maxCoord)[0];\n    midline = Math.floor(xmax / 2);\n  }\n\n  const createGrid = (width, height) => {\n    coords = [];\n  \n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const coord = `${x},${y}`; // x,y\n        coords.push(coord);\n      }\n    }\n    maxCoord = `${width - 1},${height - 1}`;\n\n    // set midpoints\n    setMidpoint();\n\n    // set coords for sun and water\n    setResourceCoords();\n\n    // set midline\n    setMidline();\n\n    return coords; // ['0,0', '1,0', '2,0', ..., 'width,height']\n  }\n\n  const createPlant = () => {\n    plant = Plant(midpoint, midline);\n\n    // setCoords\n    plant.setCoords(coords);\n\n    // sprout\n    plant.sprout();\n\n    return plant;\n  }\n\n  const createSun = () => {\n    const sun = Resource('sun', sunCoords);\n    resources.push(sun);\n  }\n\n  const createWater = () => {\n    const water = Resource('water', waterCoords);\n    resources.push(water);\n  }\n\n  const getMaxCoord = () => maxCoord;\n\n  const getMidpoint = (type) => {\n    return midpoint[type];\n  }\n  const getMidline = () => midline;\n\n  const getAbiotic = (coord) => {\n    const y = parseCoord(coord)[1];\n    if (y < soilLine) {\n      return 'air';\n    } else {\n      return 'soil';\n    }\n  }\n\n  const getResources = () => resources;\n\n  const harvestResource = (coord) => {\n    // remove resource at that coord\n    resources = resources.filter(x => ! x.getCoords().includes(coord)); // TODO: make this remove max 1 resource\n\n  }\n\n  const mapCoords = () => {\n\n    // plant\n    let plantCoords;\n    if (plant) {\n      plantCoords = plant.getCoords();\n    }\n\n    // resources\n    let resourcesCoords = {};\n    // iterate over resources (sun and water objects)\n    for (let i = 0; i < resources.length; i++) {\n      const resCoords = resources[i].getCoords(); // array of coords for each resource\n      const type = resources[i].getType(); // 'sun' or 'water'\n      \n      // iterate over coords of single resource\n      for (let j = 0; j < resCoords.length; j++) {\n        // add to overall resourcesCoords object: 'coord': 'sun' or 'water'\n        resourcesCoords[resCoords[j]] = type;\n      }\n    }\n\n    let map = {};\n    for (let i = 0; i < coords.length; i++) {\n\n      // populate coords\n      const coord = coords[i];\n      map[coord] = {};\n\n      // environment\n      map[coord]['environment'] = getAbiotic(coord); // 'soil' or 'air'\n\n      // plant\n      if (plantCoords) {\n        map[coord]['plant'] = plantCoords[coord]; // 'shoot' or 'root' or 'flower' or ''\n        // TODO: get stage of flower\n      }\n\n      // resources\n      if (resourcesCoords[coord]) {\n        map[coord]['resource'] = resourcesCoords[coord] // 'sun' or 'water'\n      }\n      \n    }\n\n    return map;\n  }\n\n  const getMap = () => {\n    return mapCoords();\n  }\n\n  const tick = () => {\n    // moves all resources\n    const resourcesToRemove = [];\n    for (let i = 0; i < resources.length; i++) {\n      resources[i].move();\n      // if resource is no longer in a legal space, mark it for removal\n      if (! resources[i].areCoordsLegal()) {\n        resourcesToRemove.push(resources[i]); // mark for removal\n      }\n    }\n    // remove all marked resources\n    resources = resources.filter(resource => ! resourcesToRemove.includes(resource));\n    \n    if (plant !== null) {\n      plant.tick();\n    }\n  }\n\n  const toString = () => { // for development\n    // get map object\n    let map = mapCoords();\n\n    const codes = {\n      'air':    ' ',\n      'soil':   '.',\n\n      'shoot':  's',\n      'root':   'r',\n\n      'bud':               '1', // TODO: get Plant.getCoords() to return flower stage instead of just 'flower'\n      'flower':            '2',\n      'fertilized flower': '3',\n      'fruit':             '4',\n      'ripe fruit':        '5',\n      'dispersed seeds':   '6',\n\n      'sun':    'p',\n      'water':  'w',\n    }\n\n    // compile and collapse into a string\n    let str = '';\n\n    let arr = coords.map(coord => {\n      let pixel = map[coord]; // { environment: string, plant: string, [resource: string] }\n      let code = '';\n\n      // layering: resource > plant > environment\n\n      // environment\n      code = codes[pixel.environment];\n\n      // plant\n      if (pixel.plant && pixel.plant !== '') {\n        code = codes[pixel.plant];\n      }\n\n      // environment\n      if (pixel.resource) {\n        code = codes[pixel.resource];\n      }\n\n      // end of line\n      if (parseCoord(coord)[0] === parseCoord(maxCoord)[0]) {\n        code += '\\n';\n      }\n      return code;\n    });\n\n    str = arr.join('');\n\n    return str;\n  }\n\n  const doVerb = (verb) => {\n    return plant.doVerb(verb);\n    // TODO: refreshes map (?)\n    // TODO: refresh readyVerbs\n  }\n\n  const getSeeds = () => plant.getSeeds();\n\n  const getPlant = () => plant;\n\n  const getFlowerVerbs = () => {\n    if (plant) {\n      return plant.getFlowerVerbs();\n    } else {\n      return false;\n    }\n  }\n\n  const getCoords = () => coords;\n\n  return {\n    createGrid,\n    createPlant,\n    createSun, createWater,\n    getMaxCoord, getMidpoint, getMidline,\n    getAbiotic,\n    getResources,\n    harvestResource,\n    tick,\n    toString,\n    getMap,\n    doVerb,\n    getSeeds,\n    getPlant,\n    getFlowerVerbs,\n    getCoords,\n  }\n}\n\nexport default Habitat;","import Habitat from './Habitat';\n\nconst Game = () => {\n  const resourceFreq = 3;\n\n  let hab;\n  let map = {};\n  let coords = {};\n  // let readyVerbs = [];\n  let energy = 0;\n  let seeds = 0;\n  let time = 0;\n\n  const verbMenu = [ // TODO: Meditate on these numbers\n    // TODO later: adjust these numbers for different habitats/plant types\n    {\n      verb: 'growShoots',\n      cost: 20,\n      area: 'shoot',\n    },\n    {\n      verb: 'growRoots',\n      cost: 20,\n      area: 'root',\n    },\n    {\n      verb: 'newShoot',\n      cost: 10,\n      area: 'shoot',\n    },\n    {\n      verb: 'newRoot',\n      cost: 10,\n      area: 'root',\n    },\n    {\n      verb: 'bloom',\n      cost: 10,\n      area: 'shoot',\n    },\n    {\n      verb: 'blossom',\n      cost: 20,\n      area: 'flower',\n    },\n    {\n      verb: 'fertilize',\n      cost: 20,\n      area: 'flower',\n    },\n    {\n      verb: 'fruit',\n      cost: 50,\n      area: 'flower',\n    },\n    {\n      verb: 'ripen',\n      cost: 30,\n      area: 'flower',\n    },\n    {\n      verb: 'disperse',\n      cost: 10,\n      area: 'flower',\n    },\n  ]\n\n  const init = (width, length) => {\n    // initialize habitat\n    hab = Habitat();\n    hab.createGrid(width, length);\n    hab.createPlant();\n\n    coords = hab.getCoords();\n    map = hab.getMap();\n\n    // initialize energy\n    energy = 100;\n\n  }\n\n\n  const createResource = () => {\n    // flip a coin: water or sun?\n    const resources = ['createWater', 'createSun'];\n    const type = resources[Math.floor(Math.random() * resources.length )];\n    // call hab.createSun() or hab.createWater();\n    hab[type]();\n\n    // don't update map here; this should only be called by tick();\n  }\n\n  const harvestResource = ( coord ) => {\n    // remove from habitat\n    hab.harvestResource(coord);\n\n    // add energy\n    energy += 25;\n\n    // update map\n    map = hab.getMap();\n  }\n\n  const tick = () => {\n    // flip a coin: create a resource?\n    const roll = Math.floor(Math.random() * resourceFreq);\n    if (roll === 0) { // success\n      createResource();\n    }\n\n    // tick the habitat along\n    hab.tick();\n\n    // update map\n    map = hab.getMap();\n\n    // update time\n    time ++;\n  }\n\n  const doVerb = (verb) => {\n    // is verb ready?\n    // if (! getReadyVerbs().includes(verb)) {\n    //   // throw new Error(`${verb} is not available.`); // TODO: fix how this is structured\n    // }\n\n    // enough energy?\n    const cost = verbMenu.filter( x => x.verb === verb)[0].cost;\n\n    if (cost > energy) { // not enough energy\n      throw new Error(`Not enough energy`);\n    }\n\n    // do it\n    const result = hab.doVerb(verb);\n\n    if (result) {\n      // deduct energy\n      energy -= cost;\n    } else {\n      throw new Error(`Cannot ${verb}`);\n    }\n\n    // update things\n    map = hab.getMap();\n    seeds = hab.getSeeds();\n\n    // return\n    return result;\n  }\n\n  const getReadyVerbs = () => { // TODO: Make readyVerbs a variable and update when necessary\n    let verbs = [\n      'growShoots',\n      'growRoots',\n      'newShoot',\n      'newRoot',\n      'bloom',\n    ];\n    // plus any flower verbs\n    const flowerVerbs = hab.getFlowerVerbs()[1]; // hab.getFlowerVerbs() returns [arr nextVerbs, arr readyVerbs]\n    verbs = [...verbs, flowerVerbs].flat();\n    \n    // return verbMenu if verb in verbs\n    return verbMenu.filter( x => verbs.includes(x.verb));\n  }\n\n  const getMap = () => map;\n  const getEnergy = () => energy;\n  const getCoords = () => coords;\n  const getSeeds = () => seeds;\n  const getTime = () => time;\n\n  return {\n    init,\n    doVerb,\n    harvestResource,\n    tick,\n    getReadyVerbs,\n    getMap,\n    getEnergy,\n    getCoords,\n    getSeeds,\n    getTime,\n  }\n}\n\nexport default Game;","import { useState } from 'react';\n\nimport Game from './Game';\n\nimport './App.css';\n\nconst XMAX = 9;\nconst YMAX = 9;\nconst timeStepMS = 2000;\nconst SEASON = 200;\n\nconst App = () => {\n  const [display, setDisplay] = useState('new');\n\n  const [game, setGame] = useState({});\n  const [map, setMap] = useState({});\n  \n  const [energy, setEnergy] = useState(0);\n  const [time, setTime] = useState(0);\n  const [timer, setTimer] = useState(0);\n  const [seeds, setSeeds] = useState(0);\n\n  const [readyVerbs, setReadyVerbs] = useState([]);\n\n  const newGame = () => {\n    // first kill the old game;\n    if (timer) {\n      clearInterval(timer);\n    }\n\n    setDisplay('play');\n\n    const newGame = Game();\n    newGame.init(XMAX + 1, YMAX + 1);\n\n    setGame(newGame);\n    setMap(newGame.getMap());\n    setEnergy(newGame.getEnergy());\n    setSeeds(newGame.getSeeds());\n    setReadyVerbs(newGame.getReadyVerbs());\n\n    setTimer(setInterval( () => tick(newGame), timeStepMS));\n  }\n\n  const tick = (gameToTick) => {\n    // make game tick\n    gameToTick.tick();\n\n    // is the season over?\n    if (gameToTick.getTime() > SEASON) {\n      endGame();\n    } else {\n      // update\n      setMap(gameToTick.getMap());\n      setTime(gameToTick.getTime());\n      setReadyVerbs(gameToTick.getReadyVerbs());\n    }\n  }\n\n  const doVerb = (verb) => {\n    // send it to game\n    try {\n      game.doVerb(verb);\n    } catch (error) {\n      console.error(error); // Show errors\n    }\n    \n    // update everything\n    setMap(game.getMap());\n    setReadyVerbs(game.getReadyVerbs());\n    setEnergy(game.getEnergy());\n    setSeeds(game.getSeeds());\n  }\n\n  const harvestResource = (coord) => {\n    // do it in the game\n    game.harvestResource( coord );\n\n    // update map and energy\n    setMap(game.getMap());\n    setEnergy(game.getEnergy());\n\n    console.log('Harvested resource');\n  }\n\n  const endGame = () => {\n    // kill the game\n    if (timer) {\n      clearInterval(timer);\n    }\n    // update display\n    setDisplay('end');\n  }\n\n  const renderMap = () => {\n    let habitat = game.getCoords().map( (coord) => {\n      // environment\n      let pixelDisplay = map[coord].environment;\n      let text = '.';\n      let harvestable = false;\n\n      if (map[coord].plant) {\n        pixelDisplay = map[coord].plant;\n      }\n\n      // flowers\n      if (['flower', 'fertilized flower'].includes(map[coord].plant)) {\n        text = 'üå∏';\n      }\n      if (['fruit', 'ripe fruit'].includes(map[coord].plant)) {\n        text = 'üçì';\n      }\n\n      if (map[coord].resource) {\n        if (map[coord].resource === 'sun') {\n          text = '‚òÄÔ∏è';\n          // harvestable?\n          if (map[coord].plant === 'shoot') {\n            harvestable = true;\n          }\n        } else if (map[coord].resource === 'water') {\n          text = 'üíß';\n          // harvestable?\n          if (map[coord].plant === 'root') {\n            harvestable = true;\n          }\n        }\n      }\n      \n      return <div key={ coord } className={ pixelDisplay } onClick={ harvestable ? () => harvestResource(coord) : undefined }> { text } </div>\n    });\n\n    return <div className=\"habitat\">{ habitat }</div>;\n  }\n\n  const renderActions = () => {\n\n    const actions = (\n      <div className=\"actions\">\n        { readyVerbs.map( verb => <button key={ verb.verb } onClick={ () => doVerb(verb.verb) } >\n          { verb.verb } ‚ö°Ô∏è{ verb.cost }\n          </button> )}\n      </div>\n    );\n\n    return actions;\n  }\n\n  const showInstructions = () => {\n    // pause\n    // kill the timer\n    if (timer) {\n      clearInterval(timer);\n    }\n\n    // change display\n    setDisplay('instructions');\n  }\n\n  const hideInstructions = () => {\n    // set display\n    setDisplay('play');\n\n    // unpause\n    setTimer(setInterval( () => tick(game), timeStepMS));\n  }\n\n  const instructions = (\n    <div className=\"instructions\">\n      <p>Welcome to Pixel Plant!</p>\n      <p>It's spring, and your pixel plant seed has just sprouted.</p>\n      <p>As a plant, you need to soak up sunlight from your shoots and water from your roots to store ‚ö°Ô∏è energy in the form of sugar.</p>\n      <p>Use stored ‚ö°Ô∏è energy to grow, bloom new üå∏ flowers, and make those flowers form üçì fruits and disperse üå∞ seeds.</p>\n\n      <p>How many üå∞ seeds can you disperse before the end of the growing season in 200 days?</p>\n      <button onClick={ hideInstructions }>Start growing</button>\n    </div>\n  );\n\n  /////////////\n  // render\n  if (display === 'new' || Object.keys(game).length === 0) { // no game\n    return (\n      <div className=\"App\">\n        <button onClick={ newGame }>New Game</button>\n      </div>\n    );\n  } else {\n    return (\n      <div className=\"App\">\n        <div className=\"infobar\">\n          <p>PixelPlant</p>\n          <button onClick={ showInstructions }>‚ÑπÔ∏è Instructions</button>\n          <div className=\"energy\">Energy: ‚ö°Ô∏è{ energy }</div>\n          <div className=\"time\">Day: üïë { time } / { SEASON }</div>\n          <div className=\"seeds\">Seeds: üå∞ { seeds }</div>\n        </div>\n        { renderMap() }\n        { display === 'play' ? renderActions() : display === 'instructions' ? instructions : (<p className=\"end\">The growing season is over. Your plant dispersed { seeds } üå∞ seeds this season.<button onClick={ newGame }>New Game</button></p>) }\n      </div>\n    );\n  }\n  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}